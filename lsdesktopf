#!/bin/bash
# Version 1.0.1-8
#
# License: GPL3
#
# Author: Andy Crowd
# Tested in Arch Linux
# Search in *.desktop for "Categories" and "Exec"
#

unset IFS
IFS="
"
One="$1"
#Two="$2"
AddCmd=($@);

GlobalArray="/opt/share/ldf/sorted.test"
LocalArray="$HOME/.ldf/sorted.test"

### The DefDskPath variable contains list of default folders
DefDskPath+=("/etc/dynamic/launchers/scanner")
DefDskPath+=("/etc/xdg/autostart")
DefDskPath+=("/etc/xdg/xfce*/panel/launcher-*")
DefDskPath+=("/lib/gnome-settings-daemon-*/gtk-modules")
DefDskPath+=("/lib/libreoffice/share/xdg")
DefDskPath+=("/usr/etc/xdg/autostart")
DefDskPath+=("/usr/lib/gnome-settings-daemon-*/gtk-modules")
DefDskPath+=("/usr/lib/libreoffice/share/xdg")
DefDskPath+=("/usr/local/share/applications")
DefDskPath+=("/usr/share/applications")
DefDskPath+=("/usr/share/apps/kdm/programs")
DefDskPath+=("/usr/share/apps/kdm/sessions")
DefDskPath+=("/usr/share/apps/solid/actions")
DefDskPath+=("/usr/share/autostart")
DefDskPath+=("/usr/share/dist/desktop-files/default")
DefDskPath+=("/usr/share/gdm/")
#DefDskPath+=("/usr/share/gdm/autostart")
#DefDskPath+=("/usr/share/gdm/autostart/LoginWindow")
#DefDskPath+=("/usr/share/gdm/greeter/autostart")
DefDskPath+=("/usr/share/gnome/autostart")
DefDskPath+=("/usr/share/kde*")
DefDskPath+=("/usr/share/mate/wm-properties")
DefDskPath+=("/usr/share/mga/dm")
DefDskPath+=("/usr/share/mimelnk/application")
DefDskPath+=("/usr/share/mimelnk/chemical")
DefDskPath+=("/usr/share/parole")
#DefDskPath+=("/usr/share/parole/parole-plugins-*")
DefDskPath+=("/usr/share/Thunar/sendto")
DefDskPath+=("/usr/share/wayland-sessions")
DefDskPath+=("/usr/share/xfce*/helpers")
DefDskPath+=("/usr/share/xfce*/panel-plugins")
DefDskPath+=("/usr/share/xfce*/panel/plugins")
DefDskPath+=("/usr/share/xgreeters")
DefDskPath+=("/usr/share/xsessions")
DefDskPath+=("/etc/xdg/autostart")
DefDskPath+=("/opt/teamviewer/tv_bin/desktop")
DefDskPath+=("/opt/wine-staging/share/applications")
DefDskPath+=("/usr/lib/gnome-settings-daemon-*.*/gtk-modules")
DefDskPath+=("/usr/lib/libreoffice/share/xdg")
DefDskPath+=("/usr/local/share/applications")
DefDskPath+=("/usr/share/applications")
DefDskPath+=("/usr/share/applications/inputmethods")
DefDskPath+=("/usr/share/apps/solid/actions")
DefDskPath+=("/usr/share/gnome/autostart")
DefDskPath+=("/usr/share/hedgewars/Data/misc")
DefDskPath+=("/usr/share/J*Z/Desktop/KDE")
DefDskPath+=("/usr/share/J*Z/Desktop/Menu")
DefDskPath+=("/usr/share/kde*/services")
DefDskPath+=("/usr/share/kde*/services/phononbackends")
DefDskPath+=("/usr/share/kde*/services/ServiceMenus")
DefDskPath+=("/usr/share/kservices*")
DefDskPath+=("/usr/share/kservices*/qimageioplugins")
DefDskPath+=("/usr/share/kservicetypes*")
DefDskPath+=("/usr/share/lirc/contrib")
DefDskPath+=("/usr/share/mimelnk/application")
DefDskPath+=("/usr/share/phoronix-test-suite/pts-core/static")
DefDskPath+=("/usr/share/Quamachi/Desktop/Menu")
DefDskPath+=("/usr/share/speech-dispatcher/conf/desktop")
DefDskPath+=("/usr/share/themes/")
DefDskPath+=("/usr/share/Thunar/sendto")
DefDskPath+=("/usr/share/xfce*/helpers")
DefDskPath+=("/usr/share/xfce*/panel-plugins")
DefDskPath+=("/usr/share/xfce*/panel/plugins")
DefDskPath+=("/usr/share/xsessions")

##########################################
AddKorora(){
 DefDskPath+=("/usr/lib64/gnome-settings-daemon-*/gtk-modules")
 DefDskPath+=("/usr/lib64/libreoffice/share/xdg")
 DefDskPath+=("/usr/share/akonadi/agents")
 DefDskPath+=("/usr/share/anaconda/gnome")
 DefDskPath+=("/usr/share/applications")
 DefDskPath+=("/usr/share/applications/kde*")
 DefDskPath+=("/usr/share/carddecks")
# DefDskPath+=("/usr/share/doc")
 DefDskPath+=("/usr/share/gcompris")
 DefDskPath+=("/usr/share/gdm/autostart/LoginWindow")
 DefDskPath+=("/usr/share/kcm_componentchooser")
 DefDskPath+=("/usr/share/kcmsolidactions")
 DefDskPath+=("/usr/share/kf*/kmoretools/presets-kmoretools")
 DefDskPath+=("/usr/share/kf*/locale/countries")
 DefDskPath+=("/usr/share/kf*/locale/currency")
 DefDskPath+=("/usr/share/khelpcenter/plugins")
 DefDskPath+=("/usr/share/khelpcenter/searchhandlers")
 DefDskPath+=("/usr/share/kio_desktop")
 DefDskPath+=("/usr/share/kmines/themes")
 DefDskPath+=("/usr/share/konqsidebartng/virtual_folders/remote")
 DefDskPath+=("/usr/share/konqsidebartng/virtual_folders/services")
 DefDskPath+=("/usr/share/konqueror/dirtree/remote")
 DefDskPath+=("/usr/share/konversation/themes")
 DefDskPath+=("/usr/share/kpackage/kcms/kcm_energyinfo")
 DefDskPath+=("/usr/share/kpackage/kcms/kcm_fileindexermonitor")
 DefDskPath+=("/usr/share/kpackage/kcms/kcm_lookandfeel")
 DefDskPath+=("/usr/share/kpackage/kcms/kcm_splashscreen")
 DefDskPath+=("/usr/share/kpat/themes")
 DefDskPath+=("/usr/share/kservicetypes*")
 DefDskPath+=("/usr/share/ksmserver/screenlocker/org.kde.passworddialog")
 DefDskPath+=("/usr/share/ksmserver/themes")
 DefDskPath+=("/usr/share/ksmserver/windowmanagers")
 DefDskPath+=("/usr/share/ksysguard/scripts/smaps")
 DefDskPath+=("/usr/share/kwin/decorations/kwin*_decoration_qml_plastik")
 DefDskPath+=("/usr/share/kwin/desktoptabbox/previews")
 DefDskPath+=("/usr/share/kwin/effects")
 DefDskPath+=("/usr/share/kwin/scripts")
 DefDskPath+=("/usr/share/kwin/tabbox")
 DefDskPath+=("/usr/share/kxmlgui*/parley/themes")
 DefDskPath+=("/usr/share/lirc/contrib")
 DefDskPath+=("/usr/share/locale/")
 #DefDskPath+=("/usr/share/locale/l10n")
 DefDskPath+=("/usr/share/parley/plugins")
 DefDskPath+=("/usr/share/parley/themes")
 DefDskPath+=("/usr/share/plasma/desktoptheme")
 DefDskPath+=("/usr/share/plasma/kcms/screenlocker_kcm")
 DefDskPath+=("/usr/share/plasma/layout-templates")
 DefDskPath+=("/usr/share/plasma/look-and-feel")
 DefDskPath+=("/usr/share/plasma/packages")
 DefDskPath+=("/usr/share/plasma/plasmoids")
 DefDskPath+=("/usr/share/plasma/shareprovider")
 DefDskPath+=("/usr/share/plasma/shells")
 DefDskPath+=("/usr/share/plasma/wallpapers")
 DefDskPath+=("/usr/share/remoteview")
 DefDskPath+=("/usr/share/sddm/themes")
 DefDskPath+=("/usr/share/services")
 DefDskPath+=("/usr/share/solid/actions")
 DefDskPath+=("/usr/share/solid/devices")
 DefDskPath+=("/usr/share/soprano/plugins")
 DefDskPath+=("/usr/share/templates")
 DefDskPath+=("/usr/share/wallpapers")
 DefDskPath+=("/usr/share/yumex-dnf")
}
##########################################
### Uncomment below to add directories found in Korora Linux
#AddKorora
#####
if [[  ! -f "$LocalArray" ]];then
	if [[  -f "$GlobalArray" ]];then
	FilePath="$GlobalArray"

	else
### ADskPath contains list of "decoded" path with command "file"
### command "file" can handle wildcards such as * that is useful when it is multiple or new path with versions number is available
### command "grep" is used to separate available from not existing path
ADskPath=($(for FromDDP in "${DefDskPath[@]}";do
	file "$FromDDP";
done |sort -u | grep -v \)$ | grep ^/ |rev|cut -d: -f2- |rev))
####################
	fi
else
	FilePath="$LocalArray"
fi
if [[ "${#ADskPath[@]}" == 0 ]]; then
	ADskPath=($(sed -i -e 's/[0-9][0-9]*/*/g' -e 's/"//g' -e 's/\/$//g' -e 's/ /*/g' "$FilePath";
	while read FromFile;do echo "$FromFile"  ; 
	done < "$FilePath"|xargs file|sort -u | grep -v \)$ |grep ^/ |rev|cut -d: -f2-|rev))
### $BDskPath is used to add path that depends on such variables as $HOME and $XDG related
 BDskPath+=("$HOME/.local/share/applications")
 BDskPath+=("$HOME/.config/autostart")
 BDskPath+=("/home/$USER/.local/share/applications")
 BDskPath+=("/home/$USER/.config/autostart")

 # BDskPath+=("$XDG_CONFIG_DIRS/autostart")
 BDskPath+=("$XDG_CONFIG_HOME/autostart")
 BDskPath+=("$HOME/.local/share/xfce*/helpers")
 BDskPath+=("/home/$USER/.local/share/xfce*/helpers")
 BDskPath+=("$XDG_DATA_HOME/applications")
#############


# BDskPath+=("$HOME/.local/share")
#	 if [[ -f "$HOME/.config/user-dirs.dirs"  ]];then
#	 BPath="$(grep XDG_DESKTOP_DIR ./.config/user-dirs.dirs | cut -d= -f2- | sed -e 's/^\"//' -e 's/\"$//' )"
#	 BDskPath+=("$BPath")
#	else
#	 if [[ -f "$XDG_CONFIG_DIRS/user-dirs.dirs"  ]];then 
#	  BDskPath+=("$(grep XDG_DESKTOP_DIR "$XDG_CONFIG_DIRS/user-dirs.dirs"|cut -d= -f2-|sed -e 's/^\"//' -e 's/\"$//' )") 
#		[[ ! -z "$DesktopDir" ]] && BDskPath="$DesktopDir"  
#	 fi
#	fi

fi
#ADskPath+="$AddWithVariables";

for AddWithVariables in "${BDskPath[@]}"; do
	if [ -d "$AddWithVariables" ];then
		ADskPath+=("$AddWithVariables");

	fi
done 
#echo "${NoEmpty[@]}"
#echo "${DefDskPath[@]}"
#exit 1
### soring out only uniq path in case if $XDG related and $HOME are pointing on a similar destination. || $InDskPath, $ADskPath, NoEmpty
NoEmpty=($(for InDskPath in "${ADskPath[@]}";do echo "$InDskPath";done|sort -u;));

### used to find out path that can be used || scan-sys-path, $DskPath, NoEmpty
ReCreateDskPath(){
case "$Opts" in
	OnlyNew1 )
DskPath=($(if [[ ! -z $2 ]]; then  
	 for StartCmdLine in "$@";
	 	do
 		if [[ -d "$StartCmdLine" ]]; then
		  InPath="$StartCmdLine"
 		fi
find "$InPath" -type f -name "*\.desktop" -exec dirname "{}" \;|sort -u

 		if [[ "$InPath" == "/" ]];then 
  		exit 0
 		fi
	done
else
	find / -type f -name "*\.desktop" -exec dirname "{}" \; |sort -u
fi))
;;
	scan-sys-path )
		DskPath=($(find "/usr/"  "/etc/" "/opt/"  -type f -name "*\.desktop" -exec dirname "{}" \;|sort -u))
		;;
	*)
	DskPath=(${NoEmpty[@]})
	;;
esac
}
########################################
gdxstdalone(){      		
IFS="
"	
	case $2 in
			g | glob )
				List_XML=($(find "/usr/" "/etc/" "$HOME/.local/" "$HOME/.config"  -type f -name "*\.xml"));
			;;
			l | local )
				List_XML=($(find  "$HOME/.config" "$HOME/.local/" -type f -name "*\.xml"));
			;;
			* )
				List_XML=($(find "/usr/share/mime/packages/" "/usr/share/mime/application/" "$HOME/.local/share/" -type f -name "*\.xml"));     
	    		 ;;
		esac

	case $2 in
	0 )
	 for In_XML_List in "${List_XML[@]}";do
	find "$In_XML_List" -type f -name "*\.xml" -exec grep -e "mime-type" -e "type=" "{}" \;
		done | awk -F"\"" '{
	if(index($0,"mime-type")){
		if(index($0,"type type=")){
			ContentArray[$2]=1;
			}else{
				if(index($0," type=")){			
		ContentArray[$4]=1}}}}END{for (I in ContentArray)print I}'
	;;
	1 )
	 for In_XML_List in "${List_XML[@]}";do
	find "$In_XML_List" -type f -name "*\.xml" -exec grep -e "mime-type" -e "type=" "{}" \;
		done | awk -F"\"" '{
	if(index($0,"mime-type")){
		if(index($0,"type type=")){
			A=substr($2,0,index($2,"/")-1);
		ContentArray[A]=1;
			}else{
				if(index($0," type=")){
			B=substr($4,0,index($4,"/")-1);
		ContentArray[B]=1}}}}END{for (I in ContentArray)print I}'
	;;
	2 )
	 for In_XML_List in "${List_XML[@]}";do
	find "$In_XML_List" -type f -name "*\.xml" -exec grep -e "mime-type" -e "type=" "{}" \;
		done | awk -F"\"" '{
	if(index($0,"mime-type")){
		if(index($0,"type type=")){
			A=substr($2,index($2,"/")+1);
		ContentArray[A]=1;
			}else{
				if(index($0," type=")){
			B=substr($4,index($4,"/")+1);
		ContentArray[B]=1}}}}END{for (I in ContentArray)print I}'
	;;
	3 )
	 for In_XML_List in "${List_XML[@]}";do
	find "$In_XML_List" -type f -name "*\.xml" -exec grep "pattern=" "{}" \;
		done | awk -F"\"" '{
			if(index(tolower($0),"pattern="))ContentArray[$2]=1;			
			}END{
				for (I in ContentArray)print I
				}'
	;;
	-gfx)
	for In_XML_List in "${List_XML[@]}";do
	find "$In_XML_List" -type f -name "*\.xml" -exec awk -v ShowItems="$3" '{		
	if(index($0,"<mime-type") != 0)
		{
			Astop=1;		
		MimeTag=$0;
		NumMtag=split(MimeTag,GetMIMEinTag,"type=\"");	
		ShowMIME=substr(GetMIMEinTag[2],0,index(GetMIMEinTag[2],"\"")-1);
		};
	if(index($0,"</mime-type>") != 0){Astop=2;YES=0};
	if(Astop == 1)
		{
			SP=SP sprintf( "%s",$0);
			AltFix=SP;
		}
	else
		{
		NumPatt=split(SP,GG,"pattern");
			if(index(SP,"<comment>") != 0)
				{
					Acomment=substr(SP,index(SP,"<comment>")+9);
					Bcomment=substr(Acomment,0,index(Acomment,"</comment>")-1);	
				}
			else
				{
					Acomment=substr(SP,index(SP,"<comment ")+9);
					TMPcomment=substr(Acomment,0,index(Acomment,"</comment>")-1);		
					Bcomment=substr(TMPcomment,index(Acomment,">")+1);					
				};
			if(index(SP,"<sub-class-of") != 0)
				{
					StartTagSSC=substr(SP,index(SP,"sub-class-of")+12)
					EndTagSSC=substr(StartTagSSC,0,index(StartTagSSC,">")-2);
					gsub(/ type=/,"Sub class of: ",EndTagSSC);
					ShowSubClass=EndTagSSC;				
				}
			if(index(SP,"<generic-icon") != 0)
				{
					StartTagGI=substr(SP,index(SP,"generic-icon")+12)
					EndTagGI=substr(StartTagGI,0,index(StartTagGI,">")-2);
					gsub(/ name=/,"Icon: ",EndTagGI);
					ShowGenericIcon=EndTagGI;				
				}
				if(index(SP,"<acronym>") != 0)
				{
					StartTagAcr=substr(SP,index(SP,"<acronym>")+10)
					EndTagAcr=substr(StartTagAcr,0,index(StartTagAcr,"/")-2);				
					ShowAcronym=EndTagAcr;				
				}
				if(index(SP,"<expanded-acronym>") != 0)
				{
					StartTagEAcr=substr(SP,index(SP,"<expanded-acronym>")+18)
					EndTagEAcr=substr(StartTagEAcr,0,index(StartTagEAcr,"/")-2);				
					ShowEAcronym=EndTagEAcr;				
				}
			if(index(SP,"<alias") != 0)
				{
					StartTagAlias=substr(SP,index(SP,"<alias")+6)
					EndTagAlias=substr(StartTagAlias,0,index(StartTagAlias,">")-2);
					gsub(/ type=/,"Alias: ",EndTagAlias);
					ShowAlias=EndTagAlias;				
				}
		for(I=0; I <= NumPatt;I++)
			{
				GetStr=substr(GG[I],0,index(GG[I],"\"/>"));
				if(index(GetStr,"=") == 1 ){printf substr(GetStr,2);					
					if(length(Bcomment) == 0){printf " ----- %s",ShowMIME}else{printf " ----- %s",Bcomment};
					if(length(ShowMIME) == 0 && length(Bcomment) == 0)
						{
							AnewMIME=substr(AltFix,index(AltFix,"mime-type")+1);
							BnewMIME=substr(AnewMIME,0,index(AnewMIME,">")-1);
							CnewMIME=substr(BnewMIME,index(BnewMIME,"type=\"")+5);
							printf CnewMIME;		
						};
						NumberItems=split(ShowItems,ArrayItems,",");
						for( getItem in ArrayItems){	
					if(ArrayItems[getItem] == "sf")printf " @*\033[2;32m %s",FILENAME"\033[0m";
					if(ArrayItems[getItem] == "sm" && ShowMIME)printf " @*\033[2;93m %s",ShowMIME"\033[0m";
					if(ArrayItems[getItem] == "ssc" && ShowSubClass)printf " @*\033[2;53m %s",ShowSubClass"\033[0m";
					if(ArrayItems[getItem] == "sgi" && ShowGenericIcon)printf " @*\033[2;49m %s",ShowGenericIcon"\033[0m";	
					if(ArrayItems[getItem] == "sa" && ShowAcronym)printf " @*\033[2;49m %s",ShowAcronym"\033[0m";
					if(ArrayItems[getItem] == "sea" && ShowEAcronym)printf " @*\033[2;49m %s",ShowEAcronym"\033[0m";
					if(ArrayItems[getItem] == "sal" && ShowAlias)printf " @*\033[2;49m %s",ShowAlias"\033[0m";
					}
				printf "\n";}
		}
		SP=1}		
	}' "{}" \;
	done
	;;
	-gx ) if [[ ! -z "$3" ]];then
		for In_XML_List in "${List_XML[@]}";do
	find "$In_XML_List" -type f -name "*\.xml" -exec grep -e "mime-type" -e "type=" "{}" \;
		done | awk -F"\"" -v FindForType="$3" '{
	if(index($0,"mime-type")){
		if(index($0,"type type=")){
			A=substr($2,index($2,"/")+1);
			if(FindForType ==  substr($2,0,index($2,"/")-1))
				ContentArray[A]=1;
			}else{
				if(index($0," type=")){
			B=substr($4,index($4,"/")+1);
			if(FindForType ==  substr($2,0,index($2,"/")-1))
				ContentArray[B]=1
		}}}}END{for (I in ContentArray)print I}'
			else
			echo 'Missing options! Use first part of MIME-type,e.g. inode'
			fi
		;;
	*) 
	  for In_XML_List in "${List_XML[@]}";do
		find "$In_XML_List" -type f -name "*\.xml" -print0 | xargs -0 awk -F"\"" '{YesM=0;
		if(index($0,"mime-type")){if(index($0,"type type=")){ContentArray[Count++]=$2" == ";YesM=1}else{if(index($0," type=")){
			ContentArray[Count++]=$4" == "}}}				
		if(index($0,"<comment>")){
			GetString=substr($0,index($0,">")+1)
			GetTMP=" "substr(GetString,0,index(GetString,"</")-1)" \n";			
			ContentArray[Count++]=GetTMP;
			YesC=1
			};
		if(index(tolower($0),"pattern="))
		{
		ContentArray[Count++]=$2" ;\n";		
		}
			}END{printf "\n@ \033[2;32m"FILENAME"\033[0m\n";
		for(GetContent in ContentArray){
			if(index(ContentArray[GetContent],"==") != 0 )printf "\n";
			if(split(ContentArray[GetContent],TMP,"/") != 1  && index(ContentArray[GetContent],"==") == 0)
				{
				printf "\n %s",ContentArray[GetContent];
			}else{
				printf "%s",ContentArray[GetContent];
				};
			};
				}' ;			
				done	
		;;
		esac
}
### ListDefault listing or searching in default output for content of Name, Exec, Comment. || awk, DskPath, fdPath
ListDefault(){
for fdPath in "${DskPath[@]}";do
if [[ ! -z "$1"   ]];then
 if [[ "$One" ==  "--all-sys-path" || "$1" == --asc ]];then
	 One="$2"
 fi
fi
if [[ -d "${DskPath[Count]}" || -f "${DskPath[Count]}"  ]];
 then
  printf "#\e[1;36m %s ${fdPath} \e[0m \n";
  if [ ! -z "$One" ] && [[ -d "${fdPath}"  || -f "${fdPath}" ]] ;
    then
     find "${fdPath}" -iname "*\.desktop" -exec awk -v Fil="{}"  -v Seek="$One" -F"=" '//{
if(index($0,"Categories=") >= 1) Ctgr=substr($0,index($0,"=")+1);
if(index($0,"Name=")       == 1) inNm=substr($0,index($0,"=")+1);
if(index($0,"Comment=")    == 1) inComment=substr($0,index($0,"=")+1);
if(index($0,"Command")     == 1) inCmd=substr($0,index($0,"=")+1) ;
if(index($0,"Module=")     == 1) inExc=substr($0,index($0,"=")+1);
if(index($0,"Exec=")       == 1) inExc=substr($0,index($0,"=")+1);
if(index($0,"Category=") >= 1) Ctgr=substr($0,index($0,"=")+1);
if(index($0,"X-XFCE-Binaries=") >= 1) inExc=substr($0,index($0,"=")+1);
     }END{
if(! Ctgr ){E=inNm}else{E=Ctgr};
if(! inExc){CmdLine=inCmd}else{CmdLine=inExc};
if(! E)E=inComment;
 Z=CmdLine" # "E" #  "Fil;
if( index(tolower(Z),tolower(Seek)) && CmdLine  )  print Z;}' "{}" \;
    else
[[ -d "${fdPath}"  || -f "${fdPath}" ]] && find "${fdPath}" -iname "*.desktop" -exec awk -v Fil="{}"  -F"=" '//{
if(index($0,"Categories") == 1) Ctgr=substr($0,index($0,"=")+1);
if(index($0,"Name=")      == 1) inNm=substr($0,index($0,"=")+1);
if(index($0,"Exec=")      == 1) inExc=substr($0,index($0,"=")+1);
if(index($0,"Comment=")   == 1) inComment=substr($0,index($0,"=")+1);
if(index($0,"Command=")   == 1) inCmd=substr($0,index($0,"=")+1) ;
if(index($0,"Category=") >= 1) Ctgr=substr($0,index($0,"=")+1);
if(index($0,"X-XFCE-Binaries=") >= 1) inExc=substr($0,index($0,"=")+1);
}END{
if(! Ctgr ){E=inNm}else{E=Ctgr};
if(! inExc){CmdLine=inCmd}else{CmdLine=inExc};
if(! E)E=inComment;
 Z=CmdLine" # "E" # "Fil" # "XFCEb;
if(CmdLine)print Z;}' "{}" \;
 fi;
fi
done
}
###################  Search specific ####
OffPrint="no";
SearchContentOfVariable(){
for fdPath in "${DskPath[@]}";do
if [[ -d "${DskPath[Count]}" || -f "${DskPath[Count]}"  ]];
 then
[[ "$OffPrint" == "no" ]] &&  printf "#\e[1;36m %s ${fdPath} \e[0m \n";
   if [ ! -z "$One" ] && [[ -d "${fdPath}"  || -f "${fdPath}" ]] ;
    then 
	case $Opts in
### "$var" is used to search for variable names with "grep" in *.desktop
	var )
		grep -e ^"$Var" "${AddCmd[@]:2}" -H -E -R --include "*\.desktop" "${fdPath}" 
		;;
### "ddp" is used to raw dump cotent of all *.desktop found in default path. || grep
	ddp ) 
                grep ^ -H -R --include "*\.desktop" "${fdPath}"
		;;
### "sud" showing uniq variables found in default path. || grep, cut
	sud )
		grep '=' -R -h --include "*\.desktop" "${fdPath}"|cut -d= -f 1|grep -v -e "\[" -e ^\# |sort -u
		;;
### "no-var" showing all *.desktop except them that contains contains specified string. || grep, find
	no-var )
		find "${fdPath}" -type f -iname "*\.desktop" -exec grep -H -L -e "$Var" "${AddCmd[@]:2}" "{}" \;
		;;
### "sdsn" showing only uniq section names found in default path. || grep, sed 
	sdsn )
		grep '\[*\]'$ -R -h --include "*\.desktop" "${fdPath}" | sed 's/ * //m' |grep ^'\[' |grep -v -e ^'#' -e '\]=' |sort -u
		;;
	upfd )
		if [[ ! -z "$2"  ]];then FLang="$2";
		else
			FLang="";
		fi

		find "${fdPath}" -type f -name "*\.desktop" -exec awk -v GetLang="$FLang" -v ShowAvailableLanguages="$3"  -F= '//{
		if(index($1,"[") != 0 && index($1,"[") != 1 ){split($1,Lang,"[")UniqLang[Lang[2]]++};
		if(index($1,"["GetLang"]") != 0 ){Item[cnt++]=$0}else { if(index($1,"]") == 0)Item[cnt++]=$0}
		}END{
		printf "* \033[2;32m %s",FILENAME"\033[2;0m \n";
		print "@ Total translations: "length(UniqLang);
		if(ShowAvailableLanguages)if(ShowAvailableLanguages == "all")if(length(UniqLang) != 0 ){
			for(AllLang in UniqLang){sub("]","",AllLang);printf "%s",AllLang","};print "."	
			};
		for (ItemNumber in Item)print Item[ItemNumber];			
		}' "{}" \; | grep -v ^"\#"
		;;
	more )
		find "${fdPath}" -type f -name "*\.desktop" -exec awk -v FindIt="$2"  -F= '/^create/;{ 
		ToLowerOne=tolower($1);
		ToLowerFindIt=tolower(FindIt);
		ToLowerTwo=tolower($2);
		if(index($1,"]") == 0 )
		if( index(ToLowerOne,"exec") != 0 || index(ToLowerOne,"name") != 0  || index(ToLowerOne,"comment") != 0  || index(ToLowerOne,"categories") != 0  || index(ToLowerOne,"command") != 0 || index(ToLowerOne,"module") != 0 || index(ToLowerOne,"x-xfce-binaries") != 0 )	{Var[CountV++]=$1;InString[CountS++]=substr($0,index($0,$2));
		if(FindIt)if( index($1,"Exec") != 0 || index($1,"Exec") != 0  || index($1,"Name") != 0  || index($1,"Comment") != 0  || index($1,"Categories") != 0  || index($1,"Command") != 0 || index($1,"Module") != 0 || index($1,"X-XFCE-Binaries") != 0 )if(index(ToLowerTwo,ToLowerFindIt) != 0 )YES="1"; };}END{
		if(YES == "1" ){printf "* \033[2;32m"FILENAME"\033[2;0m \n";        for(I in InString)if(length(Var[I]) != 0)print Var[I]"="InString[I]};
		if(length(FindIt) == 0){printf "* \033[2;32m "FILENAME"\033[2;0m \n";for(I in InString)if(length(Var[I]) != 0)print Var[I]"="InString[I]}}'  "{}"  \;|grep -v -e ^"#" -e ^$
		;;
#	more )
#		find "${fdPath}" -type f -name "*\.desktop" -exec awk -v FindIt="$2"  -F= '/^create/;{ 
#	 		  if(index($1,"]") == 0    && index($1,"MimeType") == 0 && index($1,"Keywords") == 0){Var[CountV++]=$1;InString[CountS++]=substr($0,index($0,$2));
#		if(FindIt)if(index($2,FindIt) != 0 && index($1,"MimeType") == 0 && index($1,"Keywords") == 0)YES="1"; };}END{
#		if(YES == "1" ){print " "FILENAME;        for(I in InString)if(length(Var[I]) != 0)print Var[I]"="InString[I]};
#		if(length(FindIt) == 0){print " "FILENAME;for(I in InString)if(length(Var[I]) != 0)print Var[I]"="InString[I]}}'  "{}"  \;|grep -v -e ^"#" -e ^$
#		;;

	less )
		find  "${fdPath}" -type f -name "*\.desktop" -exec awk -v FindIt="$2" -v Trans="$3" -F= '/^create/;{ 
		ToLowerTwo=tolower($2);
		ToLowerFindIt=tolower(FindIt);
			if(Trans)
			{
			split(Trans,ArrayTransLang,",");
			for(ReLangArray in ArrayTransLang )NewArrTrans[ArrayTransLang[ReLangArray]]=1;
			}				
		if(index($1,"]") == 0)
			{
			Var[CountV++]=$1;
			InString[CountS++]=substr($0,index($0,$2));
			if(FindIt)if(index(ToLowerTwo,ToLowerFindIt) != 0)YES="1"; 
			};
		if(index($1,"[") != 0 && index($1,"[") != 1 ){
			split($1,Lang,"[");			
			TmpLang=Lang[2];		
			UniqLang[TmpLang]++;
			sub("]","",TmpLang);
			if(Trans)
			  {
			  if( NewArrTrans[TmpLang] == 1 )
			   {   
			  Var[CountV++]=$1;
			  InString[CountS++]=substr($0,index($0,$2))
		  	   }			  				
			  }						 
			};
			if(index($1,"[") == 1){
			Var[CountV++]=$1;
			InString[CountS++]=$0}			
			}END{
		if(YES == "1" )
			{
			printf "* \033[2;32m" FILENAME "\033[0m\n @ Total translations: "length(UniqLang)": ";
			if(length(UniqLang) != 0)for(AllLang in UniqLang){sub("]","",AllLang);printf "%s",AllLang",";}				
			print " ";
			for (I in InString)if(index(Var[I],"[") != 1 && length(Var[I]) != 0 && index(Var[I],"#") != 1 )
				{
					print Var[I]"="InString[I];
				}
				else
				{
					if(index(Var[I],"[") == 1) 
						printf "\033[2;33m"Var[I]"\033[2;0m\n"
				}
			}
		if(length(FindIt) == 0)
			{
			printf "* \033[2;32m" FILENAME "\033[0m \n@ Total translations: "length(UniqLang)": ";
			if(length(UniqLang) != 0)for(AllLang in UniqLang)
				{
					sub("]","",AllLang);printf "%s",AllLang",";
				}
				print " ";
				for (I in InString)
					if(index(Var[I],"[") != 1 && length(Var[I]) != 0 && index(Var[I],"#") != 1  )
						{
							print Var[I]"="InString[I];
						}
						else
						{ 
							if(index(Var[I],"[") == 1)
						       		printf "\033[2;33m"Var[I]"\033[2;0m \n"}
			}
			     }'  "{}"  \;
		;;
	iov )
		find  "${fdPath}" -type f -name "*\.desktop" -exec awk -v FindIt="$2" -v Fname="$3" -F= '//{ 
			if(FindIt){
			SizeArray=split(FindIt,ArrayFindIt,",");
			if (index($0,"[") == 1 ) 
				YesFoundIt[CountFinds++]=$0;
			for(CountFindItArray in ArrayFindIt )
				NewArrFindIt[ArrayFindIt[CountFindItArray]]=1;
			if(NewArrFindIt[$1] == 1 )
				{
				YesFoundIt[CountFinds++]=$0;
				UniqFound[$1]=1;
				}	
			}
			}END{
			if( length(UniqFound) == SizeArray )
			{
				if(Fname == "filename" || Fname == "fn" || Fname == "sf" || Fname == "--sf" )
					printf "* \033[2;32m"FILENAME"\033[0m \n";
				for (GotFound in YesFoundIt )
				{
					if(index(YesFoundIt[GotFound],"[") == 1 )
					{
						printf "\033[2;33m"YesFoundIt[GotFound]"\033[0m \n"
					}
					else
					{
						print YesFoundIt[GotFound];
					}
				};
			}
		}' "{}" \;

		;;

	esac

    fi;
fi
done

case  "$Opts" in
### "sys-uniq" showing uniq variable names found in /usr /etc /opt path. || find, cut, grep
	sys-uniq )
		find "/usr" "/etc" "/opt"  -type f -name "*\.desktop" -exec grep ^ "{}"  \; | cut -d= -f1 | grep -v -e "\[" -e ^\#  | sort -u
		;;
### "var-sys" searching for variable name in system path /usr /etc /opt
	var-sys )
		grep -e ^"$Var" "${AddCmd[@]:2}" -H -E -R --include "*\.desktop" /usr /etc /opt
		;;
esac
}
########################################

RawView(){
for fdPath in "${DskPath[@]}";do
if [[ -d "${DskPath[Count]}" || -f "${DskPath[Count]}"  ]];
 then
 [[ "$OffPrint" == "no" ]] &&  printf "#\e[1;36m %s ${fdPath} \e[0m \n";
   if [ ! -z "$One" ] && [[ -d "${fdPath}"  || -f "${fdPath}" ]] ;
    then 
[[ "$Opts" == "suo"  ]] &&  grep ^ -R -h --include "*\.desktop" "${fdPath}";
    fi;
fi
done | case $Opts in
	suo )
		grep = |cut -d= -f1 |grep -v -e "\[" -e ^\#|sort -u
		;;
esac
}
###################
# Disabled options
###################
#By using option "all" as 3rd option will show all available translations in a *.desktop file, 
# without it will show only amount of translations or additional variables with a chosen translation.
# --uniq-per-file-default (lang) ("all") | --upfd : list variables found in default path
# --uniq-per-file-sys (lang) ("all")  | --upfs : list variables found in /usr /etc /opt'
# --uniq-per-file-default | --upfd : show uniq entries per file in default path
# --uniq-per-file-sys | --upfs : show uniq entries per file found in /usr /etc /opt'		
############################
# dump	-	dump content of *.desktop files
#	dump ) 
#		echo '
#	Dump RAW content of *.desktop files to stdout
# --dump-all | --da : search in  / (may need root rights)
# --dump-default-path | --ddp : from default path
# --dump-sys-path | --dsp : dump content from /usr /etc /opt'
#		;;
# Update a file that contains list of path
#	--upf filename
#  --update-path-file | --upf [file name]	: replacing all numbers and spaces with * in a file then sorting and leaving only uniq path'

help_def(){
	echo 'Showing all basic searchable content in a single line per file.
	Without any options it will list from all default path.
	All extended supported options begins with --
	Deafult output to search in: Name/Comment,Exec,Category, path to the file
 --all-sys-path | --asc (options)
 	using system path /usr /etc /opt

	Vertical and more userfiendly output. Search text in all available variables
 --more | --m (text)
 	using default path
 --more-sys | --ms (text)
 	using system path
 
	Same as option --more but is less userfiendly by outputing much more information
 --less | --l (text) (translation)
 	using default path
 --less-sys | --ls (text) (translation)
 	using system path /usr /etc /opt'
	}
help_debug(){
	echo '--show-me | --sm (options)
		show or search content in this script'		
	}
help_var(){
echo 'Search a value of the variables. Supporting grep syntax
 --var [variable] 
 	using default path
 --var-sys | --vs [variable]
	using system path /usr /etc /opt

	show file names that does not contain a string 
 --no-var-sys|--nvs [xx]
 	using system path /usr /etc /opt
 --no-var | --nv [text]
 	using default path

	show all uniq base variable names 
 --show-uniq-def |--sud
 	using default path
 --show-sys-uniq |--ssu
 	using system path /usr /etc /opt

	show RAW output of the uniq variables
 --show-uniq-only |--suo
 	using default path

--list-categories | --lc
	Show all categories found in "/usr/share/applications/" and "$HOME/.local/share/applications/" 

Not supporting grep syntax, using awk
	show content of choosen variables only if all them are present in the file. To show path to file use "sf" as last option.
 --including-only-var  | --iov [var1,var2] sf
	using default path
 --including-only-var-sys  | --iovs [var1,var2] sf
	using system path /usr /etc /opt'
	}
help_sec(){
echo 'Search section names in *.desktop files

	search for uniq section names
--sys-section-name 	| --ssn
 	using system path /usr /etc /opt
 --default-section-name | --dsn
 	using default path'

	}
help_config(){
echo 'Configuration
 --create-global-list | --cgl
 	scan system and save dirs into /opt/share/ldf/sorted.test
 --create-local-list  | --cll
 	scan system and save dirs into $HOME/.ldf/sorted.test

 --show-local-defaults	| --sld
 	show content of $HOME/.ldf/sorted.test
 --show-global-defaults	| --sgd
 	show content of /opt/share/ldf/sorted.test

 --show-default-directories | --sdd
 	show internal dirs defined in array DefDskPath 

 --remove-local-config
 	removing $HOME/.ldf/sorted.test
 --remove-global-config
 	removing /opt/share/ldf/sorted.test

 --find-path | --fp (path)
 	find path that contain *.desktop files, default starting path is /
 --formated-path-output | --fpo
 	same as --fp but showing already formated path (replaced numbers,spaces with *)  

 --format-path-file | --fpf [filename]
 	replace all spaces and numbers with *'
	}
help_info(){
echo 'https://specifications.freedesktop.org/desktop-entry-spec/latest/
	Short overview:
"f" - File name with full path
"u" - URL to website
"d" - Directory
"n" - Name of the file without path
	Single source:
%f %u %d %n
	Multiple sources:
%F %U %D %N
	Other:
%k URI/location of desktop file 
%v name of the device'	
	}
help_usage(){
echo 'Usage examples
 List content with default options:
	 lsdesktopf
 Search only for specific text in default output:
	 lsdesktopf gtk
	 lsdesktopf game
	 lsdesktopf --more 
	 lsdesktopf --more kde
	 lsdesktopf --less
	 lsdesktopf --less gnome 
	 lsdesktopf --less gtk zh_CN,zh_TW

 Use --var option (supporting grep syntax):
	--var-sys has same syntax as --var
	--var Name=
	--var "Name\[zn_CN\]" -e "^Exec="
 Reverse search (supporting grep syntax)
	--no-var Exec=
	--no-var-sys "Name\[en_GB\]"
 
 Use --including-only-var option to show content of choosen and optionaly show filename
 	NOTE: filename is an option and not path to existing file.
 	--iov Exec,MimeType filename
	--iov Exec,MimeType | grep -v ^#

 Use --gm option that shows various information about MIME-types in *.desktop files
	--gm 1
	--gm 
	--gm 0
	--gm -gx video
	--gm -gx text

 Scan for all *.desktop files in /usr /etc /opt
 has same syntax as without supported options
	--asc 
	--asc gtk
	Use --find-path or --fp 
	--fp 
	--fp /usr /etc'
	}
help_tips(){
	echo 'The script is based around commands: "grep", "awk", "find" 
	and a loop: for Line in "${Array[@]}";do ..;done
	command "rev" is used to reverse text that is useful to show or exclude last column
 to show only specfic column can be used commands such as awk,cut. 
	The "awk" command can use more than one symbol as delimer but "cut" supports only one
	awk -F"AB" "{print $1}"
	awk "{print substr($0,0,index($0,"AB")-2) }"
	cut -dA -f1
	to show everything after specified column
	cut -dA -f2-
	awk "{print substr($0,index($0,"AB")+2) }"
 to show amount columns in a string
 	awk -F"AB" "{print NF}"
 	awk "{print split($0,A,"AB") }"
 command "basename" is used to show only the filename but cutting away path to it.
	find / -type f -exec basename "{}" \;
	find / -type f | xargs basename
 command "dirname" is used to show only path to file.
	find / -type f -exec dirname "{}" \;
	find / -type f | xargs dirname
 hide error messages from stderr, such as e.g. "permission denied"
 	find / -type f 2> /dev/null | grep desktop'
}
help_mimetypes(){
echo 'Show list of mimetypes with associated *.desktop files. 
 --gen-mimeapps | --gm [options]
	Output is similar that is used in "mimeapps.list" file under section [Added Associations]
	Options:
		0 
	       		show only MIME-types
		1 
	       		show type of mime. First part of MIME-type 
		2 
	       		show extension. Second part of MIME-type
		3 
	       		show only filenames that can open same MIME-type
		-gx [type of MIME] 
	       		shows all extensions in your systems *.desktop files that belongs to type of MIME
		-gdx [options]
			shows MIME-types with their descriptions found in *.xml files
			by default searching only in /usr/share/mime/packages/ $HOME/.local/share/mime/packages/
			g
				search in /etc /usr $HOME/.local $HOME/.config
			l
				search in  $HOME/.local $HOME/.config
 
 --gdx [options]
	same as --gm -gdx [options]
	search in *.xml configuration files
	additional options
		0 
	       		show only MIME-types
		1 
	       		show type of mime. First part of MIME-type 
		2 
	       		show extension. Second part of MIME-type
		3 
	       		show only filename extenstions
	 -gfx [options]	
				list available file name extensions with their description found in ".xml" configuration or database files.
			additional comma separated options:
				sf 
				 show path to .xml file where was found file name extension.
				sm
				 show MIME type
				sa
				 show acronym
				sea
				 show extended acronim
				ssc
				 show sub class
				sal
				 show alias
				sgi
				 show general icon description

 --list-mimeapps | --lm 
 	List available "*mimeapps.list" with colored path and their content
' 
}

case "$1" in
--help )
	if [[ -z "$2" ]];then
	echo 'use additional options with --help'
	echo ' all	-	show all help sections
 def	-	options that are using default output
 var	-	list available variables or search a value
 sec	-	list available sections 
 usage	-	show usage of commands	
 config	-	configuration  
 debug	-	view or search in content of this script
 info	-	show short info about *.desktop specified Exec
 tips	-	show some tips about commands used in this script
 mime	-	list available mimetypes'
	else
		case "$2" in	
	mime )
		help_mimetypes
		;;
	def )
		help_def
		;;
	debug ) 
		help_debug
		;;
	var )
		help_var
		;;
	sec ) 
		help_sec
		;;
	config ) 
		help_config
		 ;;
	info ) 
		help_info	
		;;
	usage ) 
		help_usage
		;;
	tips )
		help_tips
		;;
	all )
	help_def
	help_var
	help_sec
	help_mimetypes
	help_usage
	help_config
	help_debug
	help_info
	help_tips
		;;
		esac
	fi
		;;
--var )
	ReCreateDskPath "$@"

	if [[  ! -z "$2"    ]];then  
		Var="$2"
 	if [[ "$#" -gt 2  ]];then 
	AddCmd=($@);
#	Additional="${AddCmd[@]:2}"  ;
 	fi;
		Opts="var"
	echo "${AddCmd[@]:2}"	
		SearchContentOfVariable "$@"
	else
		echo "Error, parameter to --var is missing
	example: --var MimeType"
 	fi	 	
 	;;
#--uniq-per-file-default | --upfd )
#	Opts="upfd"	
# 	ReCreateDskPath "$@"
#	SearchContentOfVariable "$@"
#	;;
#--uniq-per-file-sys | --upfs )

#	find /usr /etc /opt -type f -name "*\.desktop" -exec awk -v GetLang="ru" -F"=" '{if (index($1,"[") == 1)  printf "  "FILENAME"\n" $1"\n";if(index($1,"["GetLang"]")){print $0}else{if(index($1,"]") == 0) print $0}}' "{}" \; | grep -v ^"\#"
#		find /usr /etc /opt -type f -name "*\.desktop" -exec awk -v GetLang="$FLang" -v ShowAvailableLanguages="$3"  -F= '//{
#		if(index($1,"[") != 0 && index($1,"[") != 1 ){split($1,Lang,"[")UniqLang[Lang[2]]++};
#		if(index($1,"["GetLang"]") != 0 ){Item[cnt++]=$0}else { if(index($1,"]") == 0)Item[cnt++]=$0}
#		}END{
#		printf "  %s",FILENAME"\n";
#		print " ** Total translations: "length(UniqLang);
#		if(ShowAvailableLanguages)if(ShowAvailableLanguages == "all")if(length(UniqLang) != 0 ){
#			for(AllLang in UniqLang){sub("]","",AllLang);printf "%s",AllLang","};print "."	
#			};
#		for (ItemNumber in Item)print Item[ItemNumber];			
#		}' "{}" \; | grep -v ^"\#"
#		;;
--more | --m )
	Opts="more"
	ReCreateDskPath "$@"
        SearchContentOfVariable "$@"
	;;
--more-sys | --ms )
	find /usr /etc /opt -type f -name "*\.desktop" -exec awk -v FindIt="$2"  -F= '/^create/;{ 
		if(index($1,"]") == 0)
			{
			Var[CountV++]=$1;
			InString[CountS++]=substr($0,index($0,$2));
			if(FindIt)if(index($2,FindIt) != 0)YES="1"; };
			}END{
		if(YES == "1" )
			{
			printf "* \033[2;32m"FILENAME" \033[2;0m\n";
			for (I in InString)print Var[I]"="InString[I]
			};
		if(length(FindIt) == 0)
			{
			printf "* \033[2;32m"FILENAME"\033[2;0m\n";
			for(I in InString)print Var[I]"="InString[I]
			}
			     }'  "{}"  \;|grep -v ^"#"
	;;
--including-only-var  | --iov )
	if [[ -z "$2" ]];then
		echo 'Use options!
		Example: --iov Exec,Type filename'
		exit 1
	fi
	Opts="iov"
	ReCreateDskPath "$@"
        SearchContentOfVariable "$@"
	;;
--including-only-var-sys  | --iovs)
	if [[ -z "$2" ]];then
		echo 'Use options!
		Example: --iovs Exec,Type filename'
		exit 1
	fi
	find  /usr /etc /opt -type f -name "*\.desktop" -exec awk -v FindIt="$2" -v Fname="$3" -F= '//{ 
		if(FindIt){
		SizeArray=split(FindIt,ArrayFindIt,",");
		if (index($0,"[") == 1 ) YesFoundIt[CountFinds++]=$0;
		for(CountFindItArray in ArrayFindIt )NewArrFindIt[ArrayFindIt[CountFindItArray]]=1;
			if(NewArrFindIt[$1] == 1 )
				{
				YesFoundIt[CountFinds++]=$0;
				UniqFound[$1]=1;
				}	
		}}END{
		if( length(UniqFound) == SizeArray )
		{	if(Fname == "filename")printf "* \033[2;32m %s"FILENAME"\033[2;32m\n";
			for (GotFound in YesFoundIt )
			{
					print YesFoundIt[GotFound];
			};
		}
	}' "{}" \;
	;;	
--less | --l )
	Opts="less"
	ReCreateDskPath "$@"
        SearchContentOfVariable "$@"
	;;
--less-sys | --ls )
	find  /usr /etc /opt -type f -name "*\.desktop" -exec awk -v FindIt="$2" -v Trans="$3" -F= '/^create/;{ 
			if(Trans)
			{
			split(Trans,ArrayTransLang,",");
			for(ReLangArray in ArrayTransLang )NewArrTrans[ArrayTransLang[ReLangArray]]=1;
			}				
		if(index($1,"]") == 0)
			{
			Var[CountV++]=$1;
			InString[CountS++]=substr($0,index($0,$2));
			if(FindIt)if(index($2,FindIt) != 0)YES="1"; 
			};
		if(index($1,"[") != 0 && index($1,"[") != 1 ){
			split($1,Lang,"[");			
			TmpLang=Lang[2];		
			UniqLang[TmpLang]++;
			sub("]","",TmpLang);
			if(Trans)
			  {
			  if( NewArrTrans[TmpLang] == 1 )
			   {   
			  Var[CountV++]=$1;
			  InString[CountS++]=substr($0,index($0,$2))
		  	   }			  				
			  }						 
			};
			if(index($1,"[") == 1){
			Var[CountV++]=$1;
			InString[CountS++]=$0}			
			}END{
		if(YES == "1" )
			{
			printf "*\033[2;32m "FILENAME"\033[2;0m \n";printf "@ Total translations: "length(UniqLang)": ";
			if(length(UniqLang) != 0)for(AllLang in UniqLang){sub("]","",AllLang);printf "%s",AllLang",";}				
			print " ";
			for (I in InString)
				if(index(Var[I],"[") != 1 && length(Var[I]) != 0 && index(Var[I],"#") != 1 )
				{
					print Var[I]"="InString[I];
				}
				else
				{
					if(index(Var[I],"[") == 1)
						printf "\033[2;33m" Var[I]"\033[0m\n"
				}						
			}
		if(length(FindIt) == 0)
			{
			printf "* \033[2;32m "FILENAME"\033[2;0m \n";printf "@ Total translations: "length(UniqLang)": ";
			if(length(UniqLang) != 0)for(AllLang in UniqLang){sub("]","",AllLang);printf "%s",AllLang",";}
				print " ";
				for (I in InString)if(index(Var[I],"[") != 1 && length(Var[I]) != 0 && index(Var[I],"#") != 1 )
				{
					print Var[I]"="InString[I];
				}
				else
				{
				if(index(Var[I],"[") == 1)
					printf "\033[2;33m"Var[I]"\033[0m \n"
				}
			}		
	}'  "{}"  \;
	;;
--no-var | --nv )
	ReCreateDskPath "$@"

	if [[  ! -z "$2"    ]];then  
		Var="$2"
		Opts="no-var"
		SearchContentOfVariable "$@"
	else
		echo "Error, parameter to --no-var is missing
	example: --no-var MimeType"
 	fi	 	
 	;;
--var-sys | --vs)
#	ReCreateDskPath
	if [[  ! -z "$2"    ]];then  
	Var="$2"
# 	if [[ "$#" -gt 2  ]];then 
#	Additional="${AddCmd[@]:2}"  ;
# 	 fi;
	Opts="var-sys"
	SearchContentOfVariable "$@"
	else
		echo "Error, parameter to --var-sys is missing
	example: --var-sys MimeType"
 	fi	
	;;
--no-var-sys | --nvs )
	if [[ ! -z "$2" ]];then
		find /usr /etc /opt -type f -name "*\.desktop" -exec grep -i -H -L "$2" \;
	else
		echo 'No options are given.'
	fi
	;;
#--dump-all | --da ) 
#	grep -i ^ -H -R --include \*.desktop "/"
#	;;
#--dump-sys-path | --dsp )
#	grep -i ^ -H -R --include \*.desktop "/usr /etc /opt"
#	;;
#--dump-default-path | --ddp )
#	Opts="ddp"
#  	ReCreateDskPath "$@"
#     	SearchContentOfVariable
#	;;
--show-uniq-def | --sud )
	OffPrint="no"
	Opts="sud"
 	ReCreateDskPath "$@"
      	SearchContentOfVariable "$@"
	;;
--show-uniq-only | --suo )
	OffPrint="yes"
	Opts=suo
	ReCreateDskPath "$@"
	RawView
	;;	
--show-sys-uniq | --ssu )
		Opts="sys-uniq"
		SearchContentOfVariable "$@"
	;;
--find-path | --fp )
	if [[ ! -z "$2" ]]; then  
	for StartCmdLine in "$@"; 
		do
		if [[ -d "$StartCmdLine" ]]; then
  		InPath="$StartCmdLine"
 		fi
	find "$InPath" -type f -name "*\.desktop"  -exec dirname "{}" \; 2> /dev/null | sort -u
	 if [[ "$InPath" == "/" ]];then 
	  	exit 0
 		fi
	done
	else
		find / -type f -name "*\.desktop" -exec dirname "{}" \; 2> /dev/null | sort -u
	fi
	;;
--formated-path-output | --fpo )
	if [[ ! -z "$2" ]]; then  
	for StartCmdLine in "$@"; 
		do
		if [[ -d "$StartCmdLine" ]]; then
  		InPath="$StartCmdLine"
 		fi
	find "$InPath" -type f -name "*\.desktop"  -exec dirname "{}" \; 2> /dev/null |\
	       	sed -e 's/[0-9][0-9]*/*/g' -e 's/"//g' -e 's/\/$//g' -e 's/ /*/g' -e 's/[0-9]\.[0-9]*/*/g'  -e 's/\.\*/*/g' -e 's/**\*/*/g' |\
	       	sort -u
	 if [[ "$InPath" == "/" ]];then 
	  	exit 0
 		fi
	done
	else
		find / -type f -name "*\.desktop" -exec dirname "{}" \; 2> /dev/null |\
		      	sed -e 's/[0-9][0-9]*/*/g' -e 's/"//g' -e 's/\/$//g' -e 's/ /*/g' -e 's/[0-9]\.[0-9]*/*/g' -e 's/\.\*/*/g' -e 's/\*\**/*/g' |\
			sort -u
	fi
	;;
--all-sys-path | --asc)
	Opts="scan-sys-path"
	ReCreateDskPath "$@"
	ListDefault "$@"
	;;
--create-local-list | --cll)
	mkdir -p "$(dirname "$LocalArray")"
	find / -type f -name "*\.desktop" -exec dirname "{}" \; | sort -u > "$LocalArray"
	;;
#--update-path-file | --upf)
#	if [[ "$UID" != 0 ]];then  
#		echo 'You must start it as user root'
#		exit 1
#	else
#		if [[ -z "$2"  ]];then
#			echo 'path to file is missing'
#		else
#			if [[ -f "$2" ]];then
#				mkdir -p "$(dirname $GlobalArray)"
#				find /usr /etc /opt -type f -name "*\.desktop" -exec dirname "{}" \; | sort -u >> "$2";
#				sed -i -e 's/[0-9][0-9]*/*/g' -e 's/"//g' -e 's/\/$//g' -e 's/ /*/g' -e 's/[0-9]\.[0-9]*/*/g' -e 's/**\*/*/g' "$2";
#				uniq -u "$2" /tmp/uniq-tmp.txt
#				cp "/tmp/uniq-tmp.txt" "$2"
#			else
#				echo "Destion is not a file"
#			fi
#		fi
#	fi
#	;;

--format-path-file | --fpf )
	if [[ ! -z "$2" ]];then 
	 if [[ -f "$2" ]];then
	  if [[ $(grep -c -v ^/  "$2" ) != "0" ]];then
	   echo 'The file should contain only full path per line. ( all should begin with / )'
	  else
	   sed -i -e 's/[0-9][0-9]*/*/g' -e 's/"//g' -e 's/\/$//g' -e 's/ /*/g' -e 's/[0-9]\.[0-9]*/*/g' -e 's/\.\*/*/g' -e 's/\*\**/*/g' "$2"
	   sort -u -o "$2" "$2"
	  fi
	 else
	  echo 'Path to file is missing!'	 
	 fi 
	fi
	;;
--create-global-list | --cgl)
	if [[ "$UID" != 0 ]];then  
		echo 'You must start it as user root'
		exit 1
	else
		mkdir -p "$(dirname $GlobalArray)"
		find / -type f -name "*\.desktop" -exec dirname "{}" \; | sort -u > "$GlobalArray"
	fi
	;;

--show-local-defaults | --sld)
	if [[ -f "$HOME/.ldf/sorted.test" ]];then
		cat "$HOME/.ldf/sorted.test"
	else
		echo 'Does not exist $HOME/.ldf/sorted.test'
	fi
	;;
--show-global-defaults | --sgd)
	if [[ -f "/opt/share/ldf/sorted.test" ]];then
		cat "/opt/share/ldf/sorted.test"
	else
		echo 'Does not exist /opt/share/ldf/sorted.test'
	fi
	;;
--show-default-directories | --sdd)
	for SDD in "${DefDskPath[@]}"; do
		echo "$SDD"
	done
	;;
--remove-local-config) 
	rm -i "$HOME/.ldf/sorted.test"
	;;
--remove-global-config) 
	if [[ "$UID" -eq "0" ]];then
		rm -i "/opt/share/ldf/sorted.test"
	else
		echo 'You must be root!'
	fi
	;;
--show-me | --sm)
	if [[  -z $2 ]];then
		cat "$0"
		echo '# my path: '" $0"
	else
		grep -n "$2" "$0" | grep -v -e "IGNORE" -e ^"# "
	fi
	;;
--sys-section-name | --ssn)
	grep -e ^"\[" -h -R --include "*\.desktop"  /usr /etc /opt | sort -u
	;;
--default-section-name | --dsn)
	OffPrint="no"
	Opts='sdsn'
	ReCreateDskPath "$@"

	SearchContentOfVariable
	;;	
--generate-mimeapps.list | --gen-mimeapps | --gm )

if [[  -z "$XDG_CONFIG_HOME" ]];	then
PName="$HOME/.local/share/applications"
else
	if [[  "${XDG_CONFIG_HOME/#\//}" == "$XDG_CONFIG_HOME"   ]];	then
		PName="$HOME/$XDG_CONFIG_HOME/.local/share/applications"
	else
		PName="$XDG_CONFIG_HOME/.local/share/applications"
	fi
fi

IFS="
"
MimePathArray+=("$(
find "/usr/local/share/applications" "/usr/share/applications" "$PName" -type f -name "*\.desktop" -exec dirname "{}" \; | 
sort -u |
sed "s/$/\/\*.desktop/" )")

	case $2 in
      		-gdx | -get-description-xdg )
IFS="
"
		case $3 in
			g | glob )
				List_XML=($(find "/usr/" "/etc/" "$HOME/.local/" "$HOME/.config"  -type f -name "*\.xml"));
			;;
			l | local )
				List_XML=($(find  "$HOME/.config" "$HOME/.local/" -type f -name "*\.xml"));
			;;
			* )
				List_XML=($(find "/usr/share/mime/packages/" "/usr/share/mime/application/" "$HOME/.local/share/" -type f -name "*\.xml"));     
	    		 ;;
		esac
 for In_XML_List in "${List_XML[@]}";do
find "$In_XML_List" -type f -name "*\.xml" -print0 | xargs -0 awk -F"\"" '{YesM=0;
	if(index($0,"mime-type")){if(index($0,"type type=")){ContentArray[Count++]=$2" == ";YesM=1}else{if(index($0," type=")){
		ContentArray[Count++]=$4" == "}}}		
		
	if(index($0,"<comment>")){
		GetString=substr($0,index($0,">")+1)
		GetTMP=" "substr(GetString,0,index(GetString,"</")-1)" \n";			
		ContentArray[Count++]=GetTMP;
		YesC=1
		};
	if(index(tolower($0),"pattern="))
	{
	ContentArray[Count++]=$2" ;\n";		
	}
		}END{printf "\n@ \033[2;32m"FILENAME"\033[0m\n";
	for(GetContent in ContentArray){
		if(index(ContentArray[GetContent],"==") != 0 )printf "\n";
		if(split(ContentArray[GetContent],TMP,"/") != 1  && index(ContentArray[GetContent],"==") == 0)
		 	 {
			 printf "\n %s",ContentArray[GetContent];
		 }else{
			 printf "%s",ContentArray[GetContent];
			  };
		};
			}' ;

			
		done
	;;
		* )
		for inMime in "${MimePathArray[@]}" ;do
	[[ ! -d "$inMime" ]] && awk -F= -v MimeParts="$2" -v MimeExt="$3"  '//{
  if($1 == "MimeType"){SizeArr=split($2,MimeArray,";");
	for (inArray in MimeArray)
		if(MimeArray[inArray])
			{
				inMA=MimeArray[inArray];
				FName=FILENAME;
				GetTypeMime=substr(inMA,0,index(inMA,"/")-1)
				GetExtMime=substr(inMA,index(inMA,"/")+1)
				UniqMimeTypes[GetTypeMime]=inMA;
				UniqMimeExts[inMA]=GetExtMime;
				gsub(/[^*]*\//,"",FName);
		if(UniqMimeArray[inMA])	{
				UniqMimeArray[inMA]=UniqMimeArray[inMA]";"FName;
					}
					else
					{
				UniqMimeArray[inMA]=FName;
				NameCollect[FName]=inMA
					}
			};
		}
		}END{
		if(length(MimeParts) == 0)
			{
			for ( inMime in UniqMimeArray)
				{
				print inMime"="UniqMimeArray[inMime]";";
				}
			}
		else
			{
			if( MimeParts == "1" || MimeParts == "type" || MimeParts == "t")
				{
					for ( inMimeType in UniqMimeTypes )
						print inMimeType;
				};
			if( MimeParts == "2" || MimeParts == "ext" || MimeParts == "e" )
				{
					for ( inMimeExt in UniqMimeExts )
						print  UniqMimeExts[inMimeExt];
				};
			if(MimeParts == "3" || MimeParts == "files" || MimeParts == "f")
				{
					for(GetNames in UniqMimeArray)
						{
						TMPfilelist=UniqMimeArray[GetNames]
						NameCollect[TMPfilelist]="1";
						};
					for ( inMimeFile in NameCollect )
						print inMimeFile;
				};
			if(MimeParts == "0" || MimeParts == "mime" || MimeParts == "m")
				{
					for(GetMIME in UniqMimeArray)
						{
							print GetMIME
						;
						};										
				};
				if(MimeParts == "-gx" || MimeParts == "-g" || MimeParts == "-getext")
				if( length(MimeExt) != 0 )
					{
					for(GetMIME in UniqMimeArray)
						{GetType=substr(GetMIME,0,index(GetMIME,"/")-1)							
							if(MimeExt == GetType )print substr(GetMIME,index(GetMIME,"/")+1)
						;
						};										
					}
				else
					{print "No option are given. Use first part of MIME-type!"};

			}
		}' ${inMime} ;
			done | sort --field-separator=\= --key=1,1
			;;
			esac
		;;
--list-mime | --lm )

	List_Dirs+=("$HOME/.config/")
	List_Dirs+=("/etc/xdg/")
	List_Dirs+=("$HOME/.local/share/applications/")
	List_Dirs+=("/usr/local/share/applications/")
	List_Dirs+=("/etc/gnome/")
	List_Dirs+=("/usr/share/applications/")

	List_Dirs+=("/usr/share/mime/packages/")
	List_Dirs+=("/usr/share/mime-info/")
	if [[ -z "$2"  ]];then
		for In_List in "${List_Dirs[@]}";do
[[ -d "${In_List}" ]]	&& find "${In_List}" -type f  \( -name "*mimeapps.list" -o -name "defaults.list"  -o -name "*.keys" -o -name "*.xml" -o -name "*.mime"  \) -print0 | \
				xargs -0 awk -v GetType="$2"  '{GetListName=length(FILENAME)-4;
			if(index(FILENAME,".list") == GetListName ){
				GetContentList[CountItems++]=$0;YesFN=FILENAME
				};
			if(index(FILENAME,".keys") == GetListName){
				if(index($0,"[") == 0 && index($0,"#") == 0 && index($0,"]description") == 0 &&  index($0,"]category") == 0 && index($0,"_") == 0 )
					{
					GetContentList[CountItems++]=$0;YesFN=FILENAME;
					};
				};
			if(index(FILENAME,".xml")-1 == GetListName )
				{			
					if(index($0,"<comment>") != 0)
					{
							C=substr($0,0,index($0,"/")-2);
							GetContentList[CountItems++]=substr(C,index($0,">")+1);
							YesFN=FILENAME
					};
					if(index($0,"mime-type type=") != 0)
					{
							AA=substr($0,index($0,"\"")+1);
							GetContentList[CountItems++]=substr(AA,0,index(AA,"\"")-1)" # ";
							YesFN=FILENAME;
					}
				};
			}END{if(length(YesFN) != 0)print "* "YesFN ;for(GetList in GetContentList )print GetContentList[GetList];
		}' ;
		
		done;

	else

		for In_List in "${List_Dirs[@]}";do

		[[ -d  "${In_List}"  ]]	&&	find "${In_List}" -type f  \( -name "*mimeapps.list" -o -name "defaults.list" \) -exec awk  '{ 
		       	CollectMIMEContent[count++]=$0 
			}END{
			printf "# \033[1;36m "FILENAME "\033[0m \n";
			for (GotMIME in CollectMIMEContent)print CollectMIMEContent[GotMIME] }' "{}" \;
		done
	fi
		;;
--list-categories | --lc )
#	grep ^Categories -h -R "/usr/share/applications/" "$HOME/.local/share/applications/" | awk -F= '//{A[$2]=1}END{for(E in A)ZZ=ZZ E;split(ZZ,YY,";");asort(YY);for(I in YY)HH[YY[I]];for(QQ in HH)print QQ}'
#		#\ awk -F= '//{A[$2]=1}END{for(E in A){gsub(";","\n",E);printf E}}' | sort -u
List_Dirs=("/usr/share/applications/")
List_Dris+=("$HOME/.local/share/applications/")
List_Dris+=("/usr/local/share/applications/")
for In_List in "${List_Dirs[@]}" ;do
[[ -d "${In_List}" ]] && find "${In_List}" -exec grep ^Categories -h -R "{}" \;
done | awk -F= '//{A[$2]=1}END{for(E in A)ZZ=ZZ E;split(ZZ,YY,";");asort(YY);for(I in YY)HH[YY[I]];for(QQ in HH)print QQ}'
		#\ awk -F= '//{A[$2]=1}END{for(E in A){gsub(";","\n",E);printf E}}' | sort -u


		;;
--gdx | --get-description-xdg )
	gdxstdalone "$@"
	;;
	* ) 
	ReCreateDskPath "$@"

	ListDefault "$@"
	;;
esac
